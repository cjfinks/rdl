""" Draw a 3D vector """
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d import proj3d

class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        FancyArrowPatch.__init__(self, (0,0), (0,0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def draw(self, renderer):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, renderer.M)
        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))
        FancyArrowPatch.draw(self, renderer)

""" TO PLOT A 3D ARROW:
a = Arrow3D([0,1],[0,1],[0,1], mutation_scale=20, lw=1, arrowstyle="-|>", color="k")
fig = pp.figure()
ax.add_artist(a)
ax = fig.gca(projection='3d')
pp.show()
"""


import numpy as np

def return_random_clusters(M=100, Ndim = 4, num_clusters=4, noise=.5, centers=None, noise_type='normal'):
    """ Given basic parameters, creates an M x N array of M points in [-1-noise/2,1+noise/2]^Ndim
    (i.e. [0,1] x [0,1] ...  x [0,1] Ndim times)
    which are perturbations of a fixed set of num_clusters centers

    Default: clusters have coordinates uniform in [-1,1] and other points in clusters
    are generated by off-setting with uniform numbers in [-noise/2,noise/2]
    """
    data = np.zeros((M,Ndim))
    data_labels = np.zeros(M,dtype=int)

    if centers is None:
        centers = np.zeros((num_clusters,Ndim))
        # first pick cluster centers
        for i in xrange(num_clusters):
            centers[i] = [np.random.uniform(-1,1) for j in xrange(Ndim)]
    # pick rand center and add noise
    for i in xrange(M):
        cluster_idx = np.random.random_integers(0,num_clusters-1)
        data_labels[i] = cluster_idx
        data[i] = centers[cluster_idx]
        if noise_type == 'uniform':
            noise_vect = [np.random.uniform(-noise/2,noise/2) for j in xrange(Ndim)]
        else:
            noise_vect = noise * np.random.randn(Ndim)
        data[i] += noise_vect    
    return data, data_labels, centers


def sample_from_prob_vector(p, num_samples=1):
    """
    Given numpy probability vector p on N states produce num_samples samples
    returns: a (num_samples) integer vector with state labeled 0, ..., N-1
    
    Parameters
    ----------
    p : Type
        Description
    num_samples : int, optional
        Description (default 1)
    
    Returns
    -------
    Value : Type
        Description
    """
    N = len(p)
    p = np.array(p)
    p /= p.sum()
    idx = p.argsort()
    sorted_p = p[idx]
    right_end_points = np.cumsum(sorted_p)
    uniform = np.random.random(num_samples)
    test = np.array([uniform, ] * N).T
    sample = (test < right_end_points).astype('int')
    samples = np.zeros(num_samples)
    for i in xrange(num_samples):
        samples[i] = idx[np.searchsorted(sample[i], 1)]
    if num_samples == 1:
        return samples[0]
    return samples


def sample_from_bernoulli(p, M=1):
    """
    Returns N x M numpy array with M Bernoulli(p) N-bit samples
    
    Parameters
    ----------
    p : Type
        Description
    M : int, optional
        Description (default 1)
    
    Returns
    -------
    Value : Type
        Description
    """
    N = len(p)
    p = np.array(p)
    v_cp = np.array([p, ] * M).transpose()
    rand_vect = np.random.random((N, M))
    outcome = v_cp > rand_vect
    data = outcome.astype("int")
    if M == 1:
        return data[:, 0]
    return data

def corrupt_binary_data(data, avg_bits_corrupted=None, bits_corrupted=None):
    ndim = data.ndim
    data = np.atleast_2d(data)
    size, n = data.shape

    if avg_bits_corrupted is not None:
        p = 1.0*avg_bits_corrupted/n  # prob bit flipped
        which_to_flip = np.random.rand(size,n) < p
    elif bits_corrupted is not None:
        which_to_flip = np.random.rand(size, n).argsort(1) < bits_corrupted
    else:
        raise ValueError('either bits_corrupted or avg_bits_corrupted option has to be given')

    out = data.copy()
    out[which_to_flip] *= -1
    out[which_to_flip] += 1

    if ndim == 1: return out[0]
    return out
